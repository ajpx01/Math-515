
%% Exercise 1
%Estimating pi with alternating series, 
n=10000; % Number of iterations
approx_pi=0; %Initialize pi estimation
for r=0:n-1
    approx_pi = approx_pi+(((-1)^r)/(2*r+1)); %Algorithm from exercise 1
    approx_pi1=approx_pi*4; %Algorithm *4 to estimate pi
    tolerance=5*10^-3; % Set variable equal to tolerance for more efficient coding
    if abs(approx_pi1-pi) < tolerance % Add a tolerance to stop the algorithm at some value away from pi
        % Learned from https://www.mathworks.com/matlabcentral/answers/1837108-how-to-add-tolerance-to-iteration-
        % with-if-statement and prompting of Matlab Copilot
        break
    end
    
    fprintf('Iteration %d: Approximation of pi = %.6f\n', r, approx_pi1); % generated by Matlab Copilot through code and comment %plot
end

% loop and inputs originally suggested and generated entirely by Matlab Copilot with comment on line
% 1. Then was removed to practice coding on my own, and rewritten with my own code.
% Structure, inputs, and format were learned through Matlab Copilot


% Plot the approximation of pi against the iteration
iterations=0:199; % Run iterations 0 through 199
figure; % Create figure
loglog(iterations,tolerance,'-o') % Generate log to log plot
xlabel('Iteration'); % x-axis label
ylabel('Approximation of pi'); % y-axis label
title('Estimation of Pi using Alternating Series');
grid("on")


%% Exercise 2
% Code generated by Matlab Copilot and then edited to work for assignment

y0=4; % Initial guess for first loop
z0=4; % Initial guess for second loop
N=10; % Number of iterations
for i=0:N
    y0=(sin(y0^2)/(y0^2)); % 1st Algorithm
    y1=y0;
    fprintf('Iteration %d: Covergence to 1 = %.6f\n',i,y1)
end
for i=0:N-1
    z0=(sin(z0))^2/z0^2; % 2nd Algorithm
    z1=z0;
    fprintf('Iteration %d: Covergence to 1 = %.6f\n',i,z1)
end

%% Exercise 3
%% a)
f=[1 -12 35]; % coefficients of polynomial
a=roots(f); % store the roots of f in variable a
disp(a); % display the roots
fc=[1 -12 35-10^-2];
r=roots(fc);
disp(r); %The zeroes of the function where c=35-10^-2 differ from when c=35 by plus or minus 0.005
%The idea for the code in exercise 3 came from google gemini after searching "how to
%find all the roots/zeroes of a function in Matlab"

%% b)
g=[1 -10 25];
b=roots(g);
disp(b);
gc=[1 -10 25-10^-2];
d=roots(gc);
disp(d); %The zeroes of the function where c=25-10^-2 differs from when c=25 by plus or minus 0.1

% The function from b) has 1 less root than a), this results in a larger
% change in the root when c is changed. Hence plus or minus 0.1 > plus or
% minus 0.005


%% Exercise 5
% Below code made by Google Gemini, by search prompt "how to plot a function in matlab over an interval using 
% uniformly spaced points", but re-made to address problem. 
%% a)
x_start=-5*10^-6; % Starting point of linspace command
x_end=5*10^-6; % End point of linspace command

points=1001; % Number of evenly spaced points mapped
x5=linspace(x_start,x_end,points); % linspace with inputs from above

fx=log(1+x5)-cos(x5)-x5+1; % How to do ln in matlab was provided by google gemini
% Evaluate the function and plot the results

figure; % Learned how to display all graphs in script from 
% https://www.mathworks.com/matlabcentral/answers/684968-only-the-most-recent-graph-showing-up
plot(x5, fx)

%% b)
x3_start=-5*10^-6;
x3_end=5*10^-6;

points=1001;
x3=linspace(x3_start,x3_end,points);

%fx3=log(1+x3)-x3+1; % How to do ln in matlab was provided by google gemini
fx3=(x3.^3)/3-(1/24)*x3.^4;

figure;
plot(x3, fx3)

%% Exercise 6
x=sqrt(1.5)
TP=1+0.5*x-(1/8)*x^2+(1/16)*x^3-(1/24)*x^4 %Taylor polynomial approximation to sqrt(1+x)

errorBound = abs((1/24) * (1.5^(3/2))); % calculate theoretical error bound
fprintf('Theoretical error bound for sqrt(1.5) approximation: %.6f\n', errorBound);
% Error bound created by Matlab Copilot after prompting

%% Exercise 7
% Matrix multiplication learned from Google Gemini when trying to learn how
% to use Matlab and finding solutions to matrices
A1=[3.4 2.8; 8.0 6.6]; % Set matrix A
b1=[3.4;8.0]; % Set matrix b
xM1=A1\b1 % Division symbol came from help from 
% https://www.mathworks.com/help/matlab/ref/double.mldivide.html
% Find the solution matrix x to Ax=b

A2=A1;
b2=[3.41;8.0];
xM2=A2\b2

